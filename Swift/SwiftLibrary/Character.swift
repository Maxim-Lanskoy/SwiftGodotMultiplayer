import SwiftGodot

/// Player character controller with multiplayer support
@Godot
public class Character: CharacterBody3D {
    // MARK: - Constants

    private let normalSpeed: Float = 6.0
    private let sprintSpeed: Float = 10.0
    private let jumpVelocity: Float = 10.0

    // MARK: - Node References

    @Node("3DGodotRobot") var body: Body?
    @Node("SpringArmOffset") var springArmOffset: SpringArmCharacter?
    @Node("PlayerNick/Nickname") var nicknameLabel: Label3D?
    @Node("3DGodotRobot/RobotArmature/Skeleton3D/Bottom") var bottomMesh: MeshInstance3D?
    @Node("3DGodotRobot/RobotArmature/Skeleton3D/Chest") var chestMesh: MeshInstance3D?
    @Node("3DGodotRobot/RobotArmature/Skeleton3D/Face") var faceMesh: MeshInstance3D?
    @Node("3DGodotRobot/RobotArmature/Skeleton3D/Llimbs and head") var limbsHeadMesh: MeshInstance3D?

    // MARK: - Exports

    #exportGroup("Skin Colors")
    @Export var blueTexture: CompressedTexture2D?
    @Export var yellowTexture: CompressedTexture2D?
    @Export var greenTexture: CompressedTexture2D?
    @Export var redTexture: CompressedTexture2D?

    // MARK: - Private State

    private var currentSpeed: Float = 6.0
    private var respawnPoint = Vector3(x: 0, y: 5, z: 0)
    private var gravity: Float = 9.8
    private var canDoubleJump = true
    private var hasDoubleJumped = false

    // MARK: - Inventory

    /// Server-authoritative player inventory. Only modified via RPC on server.
    public var playerInventory: PlayerInventory?

    // MARK: - Lifecycle

    public override func _enterTree() {
        // Set multiplayer authority based on node name (which is peer_id)
        if let peerId = Int32(String(name)) {
            setMultiplayerAuthority(id: peerId)
        }

        // Enable camera only for local player
        if let camera = getNode(path: "SpringArmOffset/SpringArm3D/Camera3D") as? Camera3D {
            camera.current = isMultiplayerAuthority()
        }

        // Configure RPC methods (generated by @Rpc macro)
        _configureRpc()
    }

    public override func _ready() {
        // Get gravity from project settings
        if let gravityVariant = ProjectSettings.getSetting(name: "physics/3d/default_gravity", defaultValue: Variant(9.8)),
           let gravityValue = Float(gravityVariant) {
            gravity = gravityValue
        }

        let isLocalPlayer = isMultiplayerAuthority()

        // Initialize inventory based on role
        if isLocalPlayer {
            playerInventory = PlayerInventory()
            addStartingItems()
        } else if multiplayer?.isServer() == true {
            playerInventory = PlayerInventory()
            addStartingItems()
        } else {
            // Client requesting sync for their own character
            let localClientId = multiplayer?.getUniqueId() ?? 0
            if getMultiplayerAuthority() == localClientId {
                requestInventorySync()
            }
        }
    }

    public override func _physicsProcess(delta: Double) {
        guard isMultiplayerAuthority() else { return }

        // Check if UI is open and freeze movement
        if isOnFloor() {
            if let currentScene = getTree()?.currentScene as? Level {
                if currentScene.isChatVisible() || currentScene.isInventoryVisible() {
                    freeze()
                    return
                }
            }
        }

        // Handle jumping
        if isOnFloor() {
            canDoubleJump = true
            hasDoubleJumped = false

            if Input.isActionJustPressed(action: "jump") {
                velocity.y = jumpVelocity
                canDoubleJump = true
                body?.playJumpAnimation(jumpType: "Jump")
            }
        } else {
            velocity.y -= gravity * Float(delta)

            // Double jump
            if canDoubleJump && !hasDoubleJumped && Input.isActionJustPressed(action: "jump") {
                velocity.y = jumpVelocity
                hasDoubleJumped = true
                canDoubleJump = false
                body?.playJumpAnimation(jumpType: "Jump2")
            }
        }

        move()
        moveAndSlide()
        body?.animate(velocity, isOnFloor: isOnFloor(), isRunning: isRunning())
    }

    public override func _process(delta: Double) {
        guard isMultiplayerAuthority() else { return }
        checkFallAndRespawn()
    }

    // MARK: - Movement

    /// Freezes player movement (used when UI is open).
    public func freeze() {
        velocity.x = 0
        velocity.z = 0
        currentSpeed = 0
        body?.animate(Vector3.zero, isOnFloor: isOnFloor(), isRunning: false)
    }

    private func move() {
        var inputDirection = Vector2.zero
        if isMultiplayerAuthority() {
            inputDirection = Input.getVector(
                negativeX: "move_left",
                positiveX: "move_right",
                negativeY: "move_forward",
                positiveY: "move_backward"
            )
        }

        var direction = transform.basis * Vector3(x: inputDirection.x, y: 0, z: inputDirection.y)
        direction = direction.normalized()

        _ = isRunning()

        if let springArm = springArmOffset {
            direction = direction.rotated(axis: .up, angle: Double(springArm.rotation.y))
        }

        if direction.x != 0 || direction.z != 0 {
            velocity.x = direction.x * currentSpeed
            velocity.z = direction.z * currentSpeed
            body?.applyRotation(velocity)
            return
        }

        velocity.x = Float(GD.moveToward(from: Double(velocity.x), to: 0, delta: Double(currentSpeed)))
        velocity.z = Float(GD.moveToward(from: Double(velocity.z), to: 0, delta: Double(currentSpeed)))
    }

    /// Returns whether the player is currently sprinting.
    public func isRunning() -> Bool {
        if Input.isActionPressed(action: "shift") {
            currentSpeed = sprintSpeed
            return true
        } else {
            currentSpeed = normalSpeed
            return false
        }
    }

    private func checkFallAndRespawn() {
        if globalTransform.origin.y < -15.0 {
            respawn()
        }
    }

    private func respawn() {
        globalTransform.origin = respawnPoint
        velocity = Vector3.zero
    }

    // MARK: - Network RPCs

    /// Changes the player's displayed nickname.
    /// - Parameter newNick: The new nickname to display.
    @Rpc(mode: .anyPeer, callLocal: true, transferMode: .reliable)
    @Callable
    public func changeNick(newNick: String) {
        nicknameLabel?.text = newNick
    }

    // MARK: - Skin Customization

    /// Returns the texture for the given skin color.
    public func getTextureFromSkin(_ skinColor: SkinColor) -> CompressedTexture2D? {
        switch skinColor {
        case .blue: return blueTexture
        case .yellow: return yellowTexture
        case .green: return greenTexture
        case .red: return redTexture
        }
    }

    /// Sets the player's skin color.
    /// - Parameter skinColor: The skin color raw value (from `SkinColor` enum).
    @Rpc(mode: .anyPeer, callLocal: true, transferMode: .reliable)
    @Callable
    public func setPlayerSkin(skinColor: Int) {
        let skin = SkinColor(rawValue: skinColor) ?? .blue
        guard let texture = getTextureFromSkin(skin) else { return }

        setMeshTexture(bottomMesh, texture: texture)
        setMeshTexture(chestMesh, texture: texture)
        setMeshTexture(faceMesh, texture: texture)
        setMeshTexture(limbsHeadMesh, texture: texture)
    }

    private func setMeshTexture(_ meshInstance: MeshInstance3D?, texture: CompressedTexture2D) {
        guard let mesh = meshInstance,
              let material = mesh.getSurfaceOverrideMaterial(surface: 0) as? StandardMaterial3D else {
            return
        }
        material.albedoTexture = texture
        mesh.setSurfaceOverrideMaterial(surface: 0, material: material)
    }

    // MARK: - Inventory RPC Validation

    /// Result of RPC request validation.
    private enum RpcValidationResult {
        case allowed
        case denied(reason: String)
        case notServer
    }

    /// Validates an inventory RPC request.
    /// - Parameter allowServer: Whether to allow requests from server (peer 1).
    /// - Returns: Validation result indicating if request should proceed.
    private func validateInventoryRequest(allowServer: Bool = false) -> RpcValidationResult {
        guard multiplayer?.isServer() == true else {
            return .notServer
        }

        let requestingClient = multiplayer?.getRemoteSenderId() ?? 0
        let isLocalCall = requestingClient == 0
        let isFromOwner = requestingClient == getMultiplayerAuthority()
        let isFromServer = requestingClient == 1

        if isLocalCall || isFromOwner || (allowServer && isFromServer) {
            return .allowed
        }

        return .denied(reason: "Client \(requestingClient) unauthorized for player \(getMultiplayerAuthority())")
    }

    /// Syncs inventory to the owner client after server modification.
    private func syncInventoryToClient() {
        guard let inventory = playerInventory else { return }
        let ownerId = getMultiplayerAuthority()
        if ownerId != 1 {
            callRpcId(peerId: Int64(ownerId), method: "sync_inventory_to_owner", Variant(inventory.toDict()))
        } else {
            notifyInventoryUpdate()
        }
    }

    // MARK: - Inventory Network Functions

    /// Requests inventory sync from server. Called by clients to get their inventory state.
    @Rpc(mode: .anyPeer, callLocal: true, transferMode: .reliable)
    @Callable
    public func requestInventorySync() {
        switch validateInventoryRequest() {
        case .notServer:
            return
        case .denied(let reason):
            GD.pushWarning("requestInventorySync: \(reason)")
            return
        case .allowed:
            break
        }

        if let inventory = playerInventory {
            let ownerId = getMultiplayerAuthority()
            let requestingClient = multiplayer?.getRemoteSenderId() ?? 0
            let isLocalCall = requestingClient == 0

            if ownerId != 1 && !isLocalCall {
                callRpcId(peerId: Int64(requestingClient), method: "sync_inventory_to_owner", Variant(inventory.toDict()))
            } else {
                notifyInventoryUpdate()
            }
        }
    }

    /// Receives inventory sync from server. Only accepts data from server (peer 1).
    @Rpc(mode: .anyPeer, callLocal: true, transferMode: .reliable)
    @Callable
    public func syncInventoryToOwner(inventoryData: VariantDictionary) {
        // Only accept from server
        guard multiplayer?.getRemoteSenderId() == 1 else { return }
        guard isMultiplayerAuthority() else { return }

        if playerInventory == nil {
            playerInventory = PlayerInventory()
        }
        playerInventory?.fromDict(inventoryData)
        notifyInventoryUpdate()
    }

    /// Requests to move an item between inventory slots. Server-authoritative.
    /// - Parameters:
    ///   - fromSlot: Source slot index.
    ///   - toSlot: Destination slot index.
    ///   - quantity: Amount to move (-1 for all).
    @Rpc(mode: .anyPeer, callLocal: true, transferMode: .reliable)
    @Callable
    public func requestMoveItem(fromSlot: Int, toSlot: Int, quantity: Int = -1) {
        switch validateInventoryRequest() {
        case .notServer:
            return
        case .denied(let reason):
            GD.pushWarning("requestMoveItem: \(reason)")
            return
        case .allowed:
            break
        }

        guard let inventory = playerInventory else { return }

        // Validate slot indices
        guard fromSlot >= 0 && fromSlot < PlayerInventory.inventorySize &&
              toSlot >= 0 && toSlot < PlayerInventory.inventorySize else {
            GD.pushWarning("Invalid slot indices: from=\(fromSlot) to=\(toSlot)")
            return
        }

        var success = false
        if quantity == -1 {
            success = inventory.moveItem(fromIndex: fromSlot, toIndex: toSlot)
            if !success {
                success = inventory.swapItems(fromIndex: fromSlot, toIndex: toSlot)
            }
        } else {
            success = inventory.moveItem(fromIndex: fromSlot, toIndex: toSlot, quantity: quantity)
        }

        if success {
            syncInventoryToClient()
        }
    }

    /// Requests to add an item to inventory. Server-authoritative.
    /// - Parameters:
    ///   - itemId: The item ID from ItemDatabase.
    ///   - quantity: Amount to add.
    @Rpc(mode: .anyPeer, callLocal: true, transferMode: .reliable)
    @Callable
    public func requestAddItem(itemId: String, quantity: Int = 1) {
        switch validateInventoryRequest(allowServer: true) {
        case .notServer:
            return
        case .denied(let reason):
            GD.pushWarning("requestAddItem: \(reason)")
            return
        case .allowed:
            break
        }

        guard let inventory = playerInventory, quantity > 0 else { return }

        guard let item = ItemDatabase.shared?.getItem(itemId) else {
            GD.pushWarning("Item not found: \(itemId)")
            return
        }

        let remaining = inventory.addItem(item, quantity: quantity)
        let added = quantity - remaining

        if added > 0 {
            syncInventoryToClient()
        }
    }

    /// Requests to remove an item from inventory. Server-authoritative.
    /// - Parameters:
    ///   - itemId: The item ID to remove.
    ///   - quantity: Amount to remove.
    @Rpc(mode: .anyPeer, callLocal: true, transferMode: .reliable)
    @Callable
    public func requestRemoveItem(itemId: String, quantity: Int = 1) {
        switch validateInventoryRequest() {
        case .notServer:
            return
        case .denied(let reason):
            GD.pushWarning("requestRemoveItem: \(reason)")
            return
        case .allowed:
            break
        }

        guard let inventory = playerInventory, quantity > 0 else { return }

        let removed = inventory.removeItem(itemId: itemId, quantity: quantity)

        if removed > 0 {
            syncInventoryToClient()
        }
    }

    /// Returns the player's inventory.
    public func getInventory() -> PlayerInventory? {
        return playerInventory
    }

    // MARK: - Client-side RPC Calls

    /// Sends request to server to add an item. Handles both server and client cases.
    /// - Parameters:
    ///   - itemId: The item ID to add.
    ///   - quantity: Amount to add.
    public func sendRequestAddItem(itemId: String, quantity: Int = 1) {
        // If we're the server, call directly to avoid RPC warning
        if multiplayer?.isServer() == true {
            requestAddItem(itemId: itemId, quantity: quantity)
        } else {
            callRpcId(peerId: 1, method: "request_add_item", Variant(itemId), Variant(quantity))
        }
    }

    /// Sends request to server to move an item.
    /// - Parameters:
    ///   - fromSlot: Source slot index.
    ///   - toSlot: Destination slot index.
    public func sendRequestMoveItem(fromSlot: Int, toSlot: Int) {
        if multiplayer?.isServer() == true {
            requestMoveItem(fromSlot: fromSlot, toSlot: toSlot, quantity: -1)
        } else {
            callRpcId(peerId: 1, method: "request_move_item", Variant(fromSlot), Variant(toSlot), Variant(-1))
        }
    }

    /// Sends request to server to remove an item.
    /// - Parameters:
    ///   - itemId: The item ID to remove.
    ///   - quantity: Amount to remove.
    public func sendRequestRemoveItem(itemId: String, quantity: Int = 1) {
        if multiplayer?.isServer() == true {
            requestRemoveItem(itemId: itemId, quantity: quantity)
        } else {
            callRpcId(peerId: 1, method: "request_remove_item", Variant(itemId), Variant(quantity))
        }
    }

    private func addStartingItems() {
        guard let inventory = playerInventory,
              let db = ItemDatabase.shared else { return }

        if let sword = db.getItem("iron_sword") {
            _ = inventory.addItem(sword, quantity: 1)
        }
        if let potion = db.getItem("health_potion") {
            _ = inventory.addItem(potion, quantity: 3)
        }
    }

    /// Helper for RPC calls using SwiftGodot's Node.rpcId.
    private func callRpcId(peerId: Int64, method: String, _ args: Variant...) {
        let methodName = StringName(method)
        switch args.count {
        case 0:
            _ = rpcId(peerId: peerId, method: methodName)
        case 1:
            _ = rpcId(peerId: peerId, method: methodName, args[0])
        case 2:
            _ = rpcId(peerId: peerId, method: methodName, args[0], args[1])
        case 3:
            _ = rpcId(peerId: peerId, method: methodName, args[0], args[1], args[2])
        default:
            GD.pushError("callRpcId: Too many arguments")
        }
    }

    /// Notifies the UI that inventory has been updated.
    private func notifyInventoryUpdate() {
        if isMultiplayerAuthority() {
            if let level = getTree()?.currentScene as? Level {
                level.updateLocalInventoryDisplay()
            }
        }
    }
}
