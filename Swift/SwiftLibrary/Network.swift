import SwiftGodot

// MARK: - Player Skin Color

/// Player skin color options for character customization.
public enum SkinColor: Int, CaseIterable {
    case blue = 0
    case yellow = 1
    case green = 2
    case red = 3

    /// Creates a SkinColor from a string name.
    /// - Parameter s: Color name (case-insensitive).
    /// - Returns: Matching color or `.blue` as default.
    public static func fromString(_ s: String) -> SkinColor {
        switch s.lowercased() {
        case "blue": return .blue
        case "yellow": return .yellow
        case "green": return .green
        case "red": return .red
        default: return .blue
        }
    }
}

// MARK: - Player Info

/// Player information structure for network transmission.
///
/// Contains the player's display name and skin color choice.
/// Can be serialized to/from Godot's VariantDictionary for RPC.
public struct PlayerInfo {
    public var nick: String
    public var skin: SkinColor

    public init(nick: String = "Player", skin: SkinColor = .blue) {
        self.nick = nick
        self.skin = skin
    }

    /// Converts to VariantDictionary for network transmission.
    public func toDict() -> VariantDictionary {
        let dict = VariantDictionary()
        dict["nick"] = Variant(nick)
        dict["skin"] = Variant(skin.rawValue)
        return dict
    }

    /// Creates PlayerInfo from a VariantDictionary.
    public static func fromDict(_ dict: VariantDictionary) -> PlayerInfo {
        var info = PlayerInfo()
        if let nickVar = dict["nick"], let nickStr = String(nickVar) {
            info.nick = nickStr
        }
        if let skinVar = dict["skin"], let skinInt = Int(skinVar) {
            info.skin = SkinColor(rawValue: skinInt) ?? .blue
        }
        return info
    }
}

// MARK: - Network Manager

/// Network manager singleton handling multiplayer connections.
///
/// This class manages:
/// - Server hosting and client connections via ENet
/// - Player registration and tracking
/// - Connection lifecycle events
///
/// ## Usage
/// Configure as Godot Autoload in Project Settings.
///
/// ```swift
/// // Host a game
/// Network.shared?.startHost(nickname: "Host", skinColorStr: "blue")
///
/// // Join a game
/// Network.shared?.joinGame(nickname: "Player", skinColorStr: "red", address: "127.0.0.1")
/// ```
///
/// ## Signals
/// - `playerConnected`: Emitted when a player joins (peerId, playerInfo)
/// - `serverDisconnected`: Emitted when disconnected from server
@Godot
public class Network: Node {
    // MARK: - Singleton

    /// Shared instance. Set when added as Godot Autoload.
    /// Use optional chaining for safe access: `Network.shared?.startHost(...)`.
    nonisolated(unsafe) public static var shared: Network?

    // MARK: - Configuration

    /// Default server address for local testing.
    public static let serverAddress = "127.0.0.1"
    /// Server port number.
    public static let serverPort: Int32 = 8080
    /// Maximum number of connected players.
    public static let maxPlayers: Int32 = 10

    // MARK: - Private State

    /// Connected players dictionary [peer_id: PlayerInfo].
    private var players: [Int: PlayerInfo] = [:]

    /// Local player info.
    private var playerInfo = PlayerInfo(nick: "host", skin: .blue)

    // MARK: - Signals

    /// Emitted when a player connects. Parameters: (peerId: Int, playerInfo: VariantDictionary).
    @Signal var playerConnected: SignalWithArguments<Int, VariantDictionary>
    /// Emitted when disconnected from server.
    @Signal var serverDisconnected: SimpleSignal

    // MARK: - Lifecycle

    public override func _enterTree() {
        // Configure RPC methods (generated by @Rpc macro)
        _configureRpc()
    }

    public override func _ready() {
        Network.shared = self

        guard let mp = multiplayer else {
            GD.pushError("Network: multiplayer is nil")
            return
        }

        // Connect multiplayer signals
        mp.serverDisconnected.connect(onConnectionFailed)
        mp.connectionFailed.connect(onServerDisconnected)
        mp.peerDisconnected.connect(onPlayerDisconnected)
        mp.peerConnected.connect(onPlayerConnected)
        mp.connectedToServer.connect(onConnectedOk)
    }

    public override func _exitTree() {
        if Network.shared === self {
            Network.shared = nil
        }
    }

    public override func _process(delta: Double) {
        if Input.isActionJustPressed(action: "quit") {
            getTree()?.quit(exitCode: 0)
        }
    }

    // MARK: - Host/Join Methods

    /// Starts hosting a game server.
    /// - Parameters:
    ///   - nickname: Host player's display name.
    ///   - skinColorStr: Host player's skin color name.
    /// - Returns: Error code (.ok on success).
    public func startHost(nickname: String, skinColorStr: String) -> GodotError {
        let peer = ENetMultiplayerPeer()
        let error = peer.createServer(port: Network.serverPort, maxClients: Network.maxPlayers)
        if error != .ok {
            GD.pushError("Network: Failed to create server: \(error)")
            return error
        }

        multiplayer?.multiplayerPeer = peer

        var nick = nickname
        if nick.trimmingCharacters(in: .whitespaces).isEmpty {
            nick = "Host_\(multiplayer?.getUniqueId() ?? 1)"
        }

        playerInfo.nick = nick
        playerInfo.skin = SkinColor.fromString(skinColorStr)

        // Skip player creation for headless server
        if DisplayServer.getName() == "headless" {
            GD.print("Network: Headless server started on port \(Network.serverPort)")
            return .ok
        }

        players[1] = playerInfo
        playerConnected.emit(1, playerInfo.toDict())
        GD.print("Network: Server started on port \(Network.serverPort)")
        return .ok
    }

    /// Joins an existing game server.
    /// - Parameters:
    ///   - nickname: Player's display name.
    ///   - skinColorStr: Player's skin color name.
    ///   - address: Server IP address (defaults to localhost if empty).
    /// - Returns: Error code (.ok on success).
    public func joinGame(nickname: String, skinColorStr: String, address: String = serverAddress) -> GodotError {
        // Use default address if empty
        let serverAddr = address.trimmingCharacters(in: .whitespaces).isEmpty ? Network.serverAddress : address

        let peer = ENetMultiplayerPeer()
        let error = peer.createClient(address: serverAddr, port: Network.serverPort)
        if error != .ok {
            GD.pushError("Network: Failed to connect to \(serverAddr):\(Network.serverPort): \(error)")
            return error
        }

        multiplayer?.multiplayerPeer = peer

        var nick = nickname
        if nick.trimmingCharacters(in: .whitespaces).isEmpty {
            nick = "Player_\(multiplayer?.getUniqueId() ?? 0)"
        }

        playerInfo.nick = nick
        playerInfo.skin = SkinColor.fromString(skinColorStr)
        GD.print("Network: Connecting to \(serverAddr):\(Network.serverPort)")
        return .ok
    }

    // MARK: - Connection Handlers

    func onConnectedOk() {
        let peerId = Int(multiplayer?.getUniqueId() ?? 0)
        players[peerId] = playerInfo
        playerConnected.emit(peerId, playerInfo.toDict())
        GD.print("Network: Connected as peer \(peerId)")
    }

    func onPlayerConnected(id: Int64) {
        // Skip for headless server
        if DisplayServer.getName() == "headless" {
            return
        }
        // Send our info to the new player
        _ = rpcId(peerId: id, method: StringName("register_player"), Variant(playerInfo.toDict()))
    }

    // MARK: - RPC Methods

    /// RPC function to register a new player's info.
    @Rpc(mode: .anyPeer, callLocal: false, transferMode: .reliable)
    @Callable
    public func registerPlayer(newPlayerInfo: VariantDictionary) {
        let senderId = Int(multiplayer?.getRemoteSenderId() ?? 0)
        let info = PlayerInfo.fromDict(newPlayerInfo)
        players[senderId] = info
        playerConnected.emit(senderId, newPlayerInfo)
    }

    func onPlayerDisconnected(id: Int64) {
        players.removeValue(forKey: Int(id))
        GD.print("Network: Player \(id) disconnected")
    }

    func onConnectionFailed() {
        multiplayer?.multiplayerPeer = nil
        GD.pushWarning("Network: Connection failed")
    }

    func onServerDisconnected() {
        multiplayer?.multiplayerPeer = nil
        players.removeAll()
        serverDisconnected.emit()
        GD.print("Network: Disconnected from server")
    }

    // MARK: - Public Accessors

    /// Returns all connected players.
    public func getPlayers() -> [Int: PlayerInfo] {
        return players
    }

    /// Returns info for a specific player.
    /// - Parameter peerId: The player's peer ID.
    public func getPlayerInfo(_ peerId: Int) -> PlayerInfo? {
        return players[peerId]
    }

    /// Returns the local player's info.
    public func getLocalPlayerInfo() -> PlayerInfo {
        return playerInfo
    }
}
