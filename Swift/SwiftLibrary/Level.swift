import SwiftGodot
import Foundation

/// Main game level manager handling player spawning, UI, and game state.
///
/// This class is the central coordinator for the game scene, managing:
/// - Player spawning and removal based on network events
/// - UI state (main menu, chat, inventory)
/// - Debug functionality for testing
///
/// ## Scene Structure
/// The Level node expects the following children:
/// - `PlayersContainer`: Node3D containing spawned player characters
/// - `MainMenuUI`: Main menu control
/// - `MultiplayerChatUI`: Multiplayer chat panel
/// - `InventoryUI`: Inventory display panel
@Godot
public class Level: Node3D {
    // MARK: - Node References

    @Node("PlayersContainer") var playersContainer: Node3D?
    @Node("MainMenuUI") var mainMenu: MainMenuUI?
    @Node("MultiplayerChatUI") var multiplayerChat: MultiplayerChatUI?
    @Node("InventoryUI") var inventoryUI: InventoryUI?

    // MARK: - Exports

    #exportGroup("Scenes")
    /// The player character scene to instantiate for each player.
    @Export var playerScene: PackedScene?

    // MARK: - Private State

    private var chatVisible = false
    private var inventoryVisible = false

    // MARK: - Lifecycle

    public override func _enterTree() {
        // Configure RPC methods (generated by @Rpc macro)
        _configureRpc()
    }

    public override func _ready() {
        // Start dedicated server in headless mode
        if DisplayServer.getName() == "headless" {
            GD.print("Level: Starting dedicated server...")
            _ = Network.shared?.startHost(nickname: "", skinColorStr: "")
        }

        multiplayerChat?.hide()
        mainMenu?.showMenu()
        multiplayerChat?.setProcessInput(enable: true)

        // Connect main menu signals with weak self to avoid retain cycles
        mainMenu?.hostPressed.connect { [weak self] nickname, skin in
            self?.onHostPressed(nickname: nickname, skin: skin)
        }
        mainMenu?.joinPressed.connect { [weak self] nickname, skin, address in
            self?.onJoinPressed(nickname: nickname, skin: skin, address: address)
        }
        mainMenu?.quitPressed.connect { [weak self] in
            self?.onQuitPressed()
        }

        // Connect inventory UI signals
        inventoryUI?.inventoryClosed.connect { [weak self] in
            self?.onInventoryClosed()
        }

        // Connect chat signals
        multiplayerChat?.messageSent.connect { [weak self] msg in
            self?.onChatMessageSent(messageText: msg)
        }

        guard multiplayer?.isServer() == true else { return }

        // Server-only: connect player events
        Network.shared?.playerConnected.connect { [weak self] peerId, playerInfo in
            self?.onPlayerConnected(peerId: peerId, playerInfo: playerInfo)
        }
        multiplayer?.peerDisconnected.connect { [weak self] id in
            self?.removePlayer(id: id)
        }
    }

    // MARK: - Menu Handlers

    private func onPlayerConnected(peerId: Int, playerInfo: VariantDictionary) {
        addPlayer(id: peerId, playerInfo: playerInfo)
    }

    private func onHostPressed(nickname: String, skin: String) {
        mainMenu?.hideMenu()
        _ = Network.shared?.startHost(nickname: nickname, skinColorStr: skin)
    }

    private func onJoinPressed(nickname: String, skin: String, address: String) {
        mainMenu?.hideMenu()
        _ = Network.shared?.joinGame(nickname: nickname, skinColorStr: skin, address: address)
    }

    private func onQuitPressed() {
        getTree()?.quit(exitCode: 0)
    }

    // MARK: - Player Management

    /// Spawns a player character for the given peer.
    private func addPlayer(id: Int, playerInfo: VariantDictionary) {
        // Skip host player in headless mode
        if DisplayServer.getName() == "headless" && id == 1 {
            return
        }

        guard let container = playersContainer else { return }

        // Check if player already exists
        if container.hasNode(path: NodePath(String(id))) {
            return
        }

        guard let scene = playerScene,
              let player = scene.instantiate() as? Character else {
            return
        }

        player.name = StringName(String(id))
        player.position = getSpawnPoint()
        container.addChild(node: player, forceReadableName: true)

        // Set player info from network data
        if let players = Network.shared?.getPlayers()[id] {
            player.changeNick(newNick: players.nick)
            player.setPlayerSkin(skinColor: players.skin.rawValue)
        }
    }

    /// Returns a random spawn point around the origin.
    private func getSpawnPoint() -> Vector3 {
        let angle = Float.random(in: 0...(2 * Float.pi))
        let radius: Float = 10.0
        let x = cos(angle) * radius
        let z = sin(angle) * radius
        return Vector3(x: x, y: 0, z: z)
    }

    /// Removes a player character when they disconnect.
    private func removePlayer(id: Int64) {
        guard multiplayer?.isServer() == true,
              let container = playersContainer else { return }

        let path = NodePath(String(id))
        if container.hasNode(path: path),
           let playerNode = container.getNode(path: path) {
            playerNode.queueFree()
        }
    }

    // MARK: - Multiplayer Chat

    private func toggleChat() {
        if mainMenu?.isMenuVisible() == true {
            return
        }

        multiplayerChat?.toggleChat()
        chatVisible = multiplayerChat?.isChatVisible() ?? false
    }

    /// Returns whether the chat panel is currently visible.
    public func isChatVisible() -> Bool {
        return multiplayerChat?.isChatVisible() ?? false
    }

    public override func _input(event: InputEvent?) {
        guard let event = event else { return }

        if event.isActionPressed(action: "toggle_chat") {
            toggleChat()
        } else if chatVisible {
            if let keyEvent = event as? InputEventKey,
               keyEvent.keycode == .enter && keyEvent.pressed {
                multiplayerChat?.sendMessage()
                getViewport()?.setInputAsHandled()
            }
        } else if event.isActionPressed(action: "inventory") {
            toggleInventory()
        } else if let keyEvent = event as? InputEventKey, keyEvent.pressed {
            // Debug keys (F1, F2)
            if keyEvent.keycode == .f1 {
                debugAddItem()
            } else if keyEvent.keycode == .f2 {
                debugPrintInventory()
            }
        }
    }

    private func onChatMessageSent(messageText: String) {
        let trimmedMessage = messageText.trimmingCharacters(in: .whitespaces)
        if trimmedMessage.isEmpty {
            return
        }

        let localId = Int(multiplayer?.getUniqueId() ?? 0)
        if let playerInfo = Network.shared?.getPlayerInfo(localId) {
            _ = rpc(method: StringName("msg_rpc"), Variant(playerInfo.nick), Variant(trimmedMessage))
        }
    }

    // MARK: - RPC Methods

    /// Broadcasts a chat message to all peers.
    @Rpc(mode: .anyPeer, callLocal: true, transferMode: .reliable)
    @Callable
    public func msgRpc(nick: String, msg: String) {
        multiplayerChat?.addMessage(nick: nick, msg: msg)
    }

    // MARK: - Inventory System

    private func toggleInventory() {
        if mainMenu?.isMenuVisible() == true {
            return
        }

        guard let localPlayer = getLocalPlayer() else { return }

        inventoryVisible = !inventoryVisible
        if inventoryVisible {
            inventoryUI?.openInventory(player: localPlayer)
        } else {
            inventoryUI?.closeInventory()
        }
    }

    /// Returns whether the inventory panel is currently visible.
    public func isInventoryVisible() -> Bool {
        return inventoryVisible
    }

    private func onInventoryClosed() {
        inventoryVisible = false
    }

    /// Refreshes the inventory display (called after server sync).
    public func updateLocalInventoryDisplay() {
        inventoryUI?.refreshDisplay()
    }

    /// Returns the local player's Character node.
    private func getLocalPlayer() -> Character? {
        guard let container = playersContainer else { return nil }
        let localPlayerId = Int(multiplayer?.getUniqueId() ?? 0)
        let path = NodePath(String(localPlayerId))
        if container.hasNode(path: path) {
            return container.getNode(path: path) as? Character
        }
        return nil
    }

    // MARK: - Debug Functions

    /// Debug: Adds a random item to the local player's inventory (F1 key).
    private func debugAddItem() {
        guard let localPlayer = getLocalPlayer() else {
            GD.print("Debug: No local player found")
            return
        }

        let testItems = ["iron_sword", "health_potion", "leather_armor", "magic_gem", "iron_pickaxe"]
        let randomItem = testItems.randomElement() ?? "health_potion"
        localPlayer.sendRequestAddItem(itemId: randomItem, quantity: 1)
    }

    /// Debug: Prints the local player's inventory contents (F2 key).
    private func debugPrintInventory() {
        guard let localPlayer = getLocalPlayer(),
              let inventory = localPlayer.getInventory() else {
            GD.print("Debug: No inventory found")
            return
        }

        GD.print("=== Inventory ===")
        for i in 0..<inventory.slots.count {
            let slot = inventory.slots[i]
            if !slot.isEmpty() {
                GD.print("Slot \(i): \(slot.itemId) x\(slot.quantity)")
            }
        }
    }
}
